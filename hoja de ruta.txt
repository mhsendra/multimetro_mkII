ğŸ§­ Hoja de ruta â€“ MultÃ­metro DIY mÃ¡s robusto (v4 conceptual)
FASE 0 â€” Congelar el estado actual (muy importante)

Antes de mejorar nada:

ğŸ“Œ Congelar:

esquemÃ¡tico actual

firmware que funciona

ğŸ§ª Medir y anotar:

errores tÃ­picos por rango

ruido

tiempos de respuesta

ğŸ“ Documentar:

quÃ© ADC mide quÃ©

quÃ© SEL controla quÃ© rango

ğŸ‘‰ Esto es tu baseline. Sin esto, cualquier mejora es a ciegas.

FASE 1 â€” Robustecer el HARDWARE (sin cambiar MCU)
1.1 ProtecciÃ³n de entradas (prioridad absoluta)
ğŸ”Œ Entrada de voltaje (DC/AC)

Objetivo: que un error humano no mate el ADC.

Implementar (todo THT, clÃ¡sico, probado):

ğŸ”¥ PTC resettable en serie con la entrada

âš¡ MOV o TVS (dependiendo del rango mÃ¡ximo esperado)

ğŸ§² Diodos rÃ¡pidos a VCC/GND (1N4148 o BAV21)

ğŸªœ Resistencia serie fija antes del divisor

Resultado:

El ADC nunca ve mÃ¡s allÃ¡ de Â±0.3 V fuera de rails

El firmware ya no depende de â€œno equivocarseâ€

1.2 ProtecciÃ³n en modo Ohm / Continuidad / Diodo

AquÃ­ es donde mueren muchos DIY.

AÃ±adir:

Resistencia serie fija SIEMPRE presente

Diodos de clamp al ADC

Limitar corriente mÃ¡xima incluso si:

entra tensiÃ³n externa

el selector estÃ¡ mal posicionado

ğŸ‘‰ Asumir que el usuario se equivoca es parte del diseÃ±o robusto.

1.3 Corriente: sacrificar precisiÃ³n por supervivencia

Shunt THT de potencia sobredimensionado

Fusible real (vidrio, lento)

ProtecciÃ³n tÃ©rmica pasiva (PTC)

El firmware no puede salvar un shunt quemado.

FASE 2 â€” Simplificar y centralizar el FIRMWARE

AquÃ­ hay mucho margen sin perder funcionalidad.

2.1 Capa Ãºnica de ADC (clave)

Ahora:

Cada modo toca ADC, referencias y rangos

Propuesta:
Crear un solo mÃ³dulo central tipo:

adc_manager.cpp


Responsabilidades:

Seleccionar canal

Seleccionar referencia

Aplicar settling time

Descartar N lecturas

Devolver valor filtrado

Los modos solo dicen:

â€œquiero leer ADC_DC en rango Xâ€

Esto:

reduce bugs

garantiza coherencia

hace trivial cambiar tiempos o filtros

2.2 Descarte sistemÃ¡tico de lecturas (obligatorio)

Regla de oro:

cada cambio de:

MUX

referencia

rango

descarta 2â€“3 lecturas

ImplementaciÃ³n:

No en cada modo

en el ADC manager

Resultado:

Menos ruido

Lecturas repetibles

Menos â€œfantasmasâ€

2.3 Centralizar rangos y escalados

Ahora:

Cada modo sabe cÃ³mo escalar

Mejor:
Una tabla de rangos global:

struct RangeConfig {
  adc_channel
  sel_state
  scale_factor
  max_value
}


Beneficios:

Cambias hardware â†’ cambias una tabla

Menos lÃ³gica duplicada

Firmware mÃ¡s legible

2.4 MÃ¡quina de estados mÃ­nima por modo

No hace falta algo complejo, pero sÃ­ explÃ­cito:

Estados tÃ­picos:

INIT

SET_RANGE

MEASURE

DISPLAY

ERROR

Esto:

evita condiciones raras

facilita depuraciÃ³n

ayuda al auto-off

FASE 3 â€” Auto-off, watchdog y robustez lÃ³gica
3.1 Auto-off inteligente

Resetear temporizador en cada mediciÃ³n vÃ¡lida

No solo por botones

Evita apagados absurdos en mediciones lentas.

3.2 Watchdog activado (sÃ­ o sÃ­)

Reset seguro si algo se cuelga

Especialmente Ãºtil con:

ADC

I2C

estados raros

Un multÃ­metro colgado = instrumento muerto.

FASE 4 â€” CalibraciÃ³n y precisiÃ³n prÃ¡ctica
4.1 CalibraciÃ³n por software (sin hardware extra)

Guardar factores en EEPROM

Calibrar:

offset

ganancia

Por rango, no global

4.2 Filtrado simple pero estable

Media mÃ³vil pequeÃ±a

Rechazo de outliers

Nada sofisticado (el 328P no da para DSP)

FASE 5 â€” ValidaciÃ³n antes de fabricar

Checklist que recomiendo sÃ­ o sÃ­:

â Conectar 12 V donde no toca â†’ Â¿sobrevive?

â Cambiar de modo con tensiÃ³n presente â†’ Â¿ADC vive?

â Selector en posiciÃ³n incorrecta â†’ Â¿algo se quema?

â MediciÃ³n lenta â†’ Â¿auto-off molesta?

â Ruido â†’ Â¿se estabiliza?

Si pasa esto, pasa casi todo.